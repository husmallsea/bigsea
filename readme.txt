线程安全性：
    当多个线程访问某个类时，不管采用何种 《调度方式》，并且在主调代码中《不需要任何同步操作》,该类都能表现出正确行为，
 那么这个类就是线程安全的；

线程安全的三个特性：
    原子性：提供了互斥访问，同一时刻只能有一个线程进行操作；
       AtomicXXX; Lock; Synchronized;

    可见性：一个线程对主存的修改可以及时被其他线程观察到；
       《1》共享变量线程不可见原因：
           1.线程交叉执行；
           2.重排序+线程交叉执行；
           3.共享变量更新后的值没有在工作内存与主内存及时更新；
       《2》可见性：
            synchronized:
                1.解锁前，必须将共享变量最新的值刷新到主存；
                2.加锁时，清空工作区的共享变量，从而使用共享变量时需要从主内存中读取最新的值；
            volatitle:(通过"内存屏障" 和 "禁止重排序" 来实现)
            详参：https://www.jianshu.com/p/2ab5e3d7e510
                1.对validate变量进行写操作时，会在写操作后添加store指令，将本地内存中的共享变量刷新到主存；
                2.对validate变量进行读操作时，会在读操作之前加load指令，从主存中读取共享变量；
                简言之，强迫从主内存中进行读写；

            volatitle 并不具备原子性（即不保证线程安全性）

================写操作示例=================

                |                  |
                |     store操作    |
                |------------------|
                |StoreStore指令屏障| ====> 禁止其他"store操作" 与 "volatitle写" 重排序
                |------------------|
                |    volatitle写   |
                |------------------|
                |StoreLoad指令屏障 | ====> 禁止"volatitle写" 与 其他"load操作" 重排序

================读操作示例=================

                |                  |
                |     volatitle读  |
                |------------------|
                | LoadLoad指令屏障 | ====> 禁止下面"load"操作与后续"load"重排序
                |------------------|
                | LoadStore指令屏障| ====> 禁止后续"store"操作与"volatitle 读" 重排序
                |------------------|


    有序性：happends-before原则；

    总结：
        原子性：Atomic包，CAS算法，synchronized,Lock;
        可见性：synchronized,volatile;
        有序性：happends-before;








